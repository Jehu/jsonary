<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
  <head>
		<title>Custom Renderers in Jsonary</title>
		<link rel="stylesheet" href="../../css/main.css">
		<link rel="stylesheet" href="../../renderers/plain.jsonary.css">
		<meta name="viewport" content="width=960">
		<style>
			.exampleTitle {
				margin: 0;
				text-align: left;
				border-bottom: 1px solid black;
				font-size: 1.3em;
				padding: 0;
				padding-left: 1em;
				padding-right: 1em;
				background-color: #EEF;
			}
			
			.exampleTitle .json-string {
				height: 1.4em;
			}
			
			.json-string {
				width: 100%;
			}
		</style>
	</head>
	<body>
		<script src="http://ajax.cdnjs.com/ajax/libs/json2/20110223/json2.js"></script>
		<script src="../../jsonary.js"></script>
		<script src="../../renderers/plain.jsonary.js"></script>
		<div align="center">
			<div id="content">
				<h1>Custom Renderers in Jsonary</h1>
				<div class="tagline">make things look pretty</div>

				<div id="nav">
					back to
					<a class="nav-link" href="../../">main page</a>
					<a class="nav-link" href="../">feature tour</a>
				</div>
				
				<div class="resource-list">
					The demos on this page use the following files:
					<ul>
						<li><span class="filename">jsonary.js</span> - the core Jsonary library
						<li><span class="filename">plain.jsonary.js</span> - a default set of renderers, that look similar to plain JSON
						<li><span class="filename">plain.jsonary.css</span> - the stylesheet used by the above renderers
					</ul>
				</div>
	
				<h2>Registering a custom renderer</h2>
				<div class="section">
					<p>The majority of the time, all you'll need to do to register a renderer with Jsonary is this:
<pre class="example code">
Jsonary.render.register({
	renderHtml: function (data, context) {
		// Return HTML for the interface
	},
	render: function (element, data, context) {
		// Perform any enhancement using the DOM.
		// If renderHtml() is defined, then "element" will be filled with that HTML.
	},
	filter: function (data, schemas) {
		// return boolean, declaring whether this renderer can render the item
		// Most of the time, it will look something like this:
		return schemas.containsUrl('some schema url');
	}
});
</pre>
					<p>All methods are optional, but either <code>renderHtml()</code> or <code>render()</code> needs to be present in order to actually do anything.
					<p>The <code>containsUrl()</code> method matches the provided argument against the URLs of the schemas as a suffix (if it's a string), so you can just pass in <code>"mySchema.json"</code>, and it will match <code>http://example.com/schemas/mySchema.json</code>.  If you pass in a regular expression, then it tests the URLs using that regular expression.
					<p>There is also an optional <code>"update"</code> method, discussed later.
				</div>

				<h2>jQuery</h2>
				<div class="section">
					<p>There is a nice jQuery-friendly way to do this as well:
<pre class="example code">
$.renderJson.register({
	"renderHtml": function (query, data, context) {
		// same as above
	},
	"render": function (query, data, context) {
		// Here, query is a jQuery object
	},
	"filter": function (data, schemas) {
		// same as above
	}
});
</pre>
				</div>

				<h2>Example</h2>
				<div class="section">
					<p>For this example, we're going to use the <code>renderHtml()</code> method.
					<p>Say we have a schema, like so: (<a href="example-schema.json">example-schema.json</a>)
<pre class="example code">
{
	"title": "Example schema",
	"type": "object",
	"properties": {
		"title": {"type": "string"},
		"message": {"type": "string"}
	}
}
</pre>
					<p>If simply rendered a (read-only) instance described by this schema, it would look like this:
					<div class="example" id="example-no-renderer"></div>
					<script>
var rawData = {"title": "Instance title", "message": "This is the message content"};
var data = Jsonary.create(rawData, null, true);
data.addSchema("example-schema-copy.json").renderTo("example-no-renderer");
					</script>
					<p>Let's try adding a custom renderer that matches that schema:
<pre class="example code">
Jsonary.render.register({
	renderHtml: function (data, context) {
		var result = '&lt;h3 class="exampleTitle"&gt';
		result += context.renderHtml(data.property("title"));
		result += '&lt;/h3&gt;&lt;div class="exampleMessage"&gt;';
		result += context.renderHtml(data.property("message"));
		result += '&lt;/div&gt;';
		return result;
	},
	filter: function (data, schemas) {
		return schemas.containsUrl("example-schema.json");
	}
});
</pre>
					<p>If we render the item, having defined this custom renderer (and a bit of CSS), it looks like this:
					<div class="example" id="example-renderer"></div>
					<script>
Jsonary.render.register({
	renderHtml: function (data, context) {
		var result = '<h3 class="exampleTitle">';
		result += context.renderHtml(data.property("title"));
		result += '</h3><div class="exampleMessage">';
		result += context.renderHtml(data.property("message"));
		result += '</div>';
		return result;
	},
	filter: function (data, schemas) {
		return schemas.containsUrl("example-schema.json");
	}
});

var rawData = {"title": "Instance title", "message": "This is the message content"};
var data = Jsonary.create(rawData, null, true);
data.addSchema("example-schema.json").renderTo("example-renderer");
					</script>
				</div>
				
				<h2>Read/write example</h2>
				<div class="section">
					<p>You might wonder why in the previous example, we called down to <code>context.renderHtml(data.property("title"))</code> instead of just using <code>data.propertyValue("title")</code>.
					<p>Partly, it protects against cross-site scripting.  However, there's a much cooler benefit - to illustrate, let's try rendering an <em>editable</em> item using exactly the same renderer:
					<div class="example" id="example-renderer-editable"></div>
					<script>
var rawData = {"title": "Instance title", "message": "This is the message content"};
var data = Jsonary.create(rawData);
data.addSchema("example-schema.json").renderTo('example-renderer-editable');
					</script>
					<p>As you should hopefully be able to see, the item is now rendered with an editable title and message.
					<p>This is one of the advantages of the rendering using Jsonary.  If instead of figuring out how to render everything yourself, you pass back to Jsonary, it can select an appropriate renderer for you, and you can piggy-back on that renderer's behaviour.
				</div>
				
				<h2>Simultaneous read/write</h2>
				<div class="section">
					<p>Since the rendered versions of the items are tied to the data, if you update the data then the displayed version changes. Here we are rendering two copies of an instance:
					<div class="example" id="example-renderer-duplicate1"></div>
					<p>and:
					<div class="example" id="example-renderer-duplicate2"></div>
					<script>
var rawData = {"title": "Duplicated item", "message": "This is the message content"};
var data = Jsonary.create(rawData).addSchema("example-schema.json");
data.renderTo('example-renderer-duplicate1');
data.renderTo('example-renderer-duplicate2');
					</script>
					<p>If you edit the title or message in one of them, then the other should change to match, as the underlying data has changed.
				</div>

				<h2>Updates</h2>
				<div class="section">
					<p>How does this magical updating work?
					<p>At the top of this page, we briefly mentioned the optional <code>update</code> property of the renderer object.  We're not going to describe it in great detail, but the basic form is:
<pre class="example code">
Jsonary.render.register({
	"renderHtml": function (element, data) {
		// rendering code
	},
	"render": function (element, data) {
		// rendering code
	},
	"update": function (element, data, operation) {
		// Update code - you can performa any DOM manipulation you like.
		// If you return boolean "true", then the item is re-rendered.
		// To fall back to the default behaviour, use the following:
		return this.defaultUpdate(element, data, operation); 
	}
	"filter": function (data, schemas) {
		return schemas.containsUrl('some schema url');
	}
});
</pre>
					<p>Whenever any data is changed, this function is called for that data <em>and its parent, grandparent and so on</em> anywhere that is still rendered on the page.  The mysterious third argument <code>operation</code> represents a single operation in a JSON Patch, which you can inspect to see what the actual change was.
					<p>Most of the time, you will not need to implement this function.  If you don't specify an update function, the default update function is called.  This function simply re-draws the item if the change occurred in the rendered data (or any of its immediate children, unless the update type is "replace").
					<p>You can fall back to the default update behaviour from within your update function by calling <code>this.defaultUpdate(element, data, operation)</code>.
				</div>
			</div>
		</div>
	</body>
</html>
