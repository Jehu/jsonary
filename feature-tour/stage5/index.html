<html>
  <head>
		<title>Custom Renderers in Jsonary</title>
		<link rel="stylesheet" href="../../css/main.css">
		<link rel="stylesheet" href="../../renderers/plain.jsonary.css">
		<meta name="viewport" content="width=960">
		<style>
			.exampleTitle {
				margin: 0;
				text-align: left;
				border-bottom: 1px solid black;
				font-size: 1.3em;
				padding-left: 1em;
				background-color: #EEF;
			}
		</style>
	</head>
	<body>
		<script src="http://ajax.cdnjs.com/ajax/libs/json2/20110223/json2.js"></script>
		<script src="../../js/jquery.js"></script>
		<script src="../../jsonary.js"></script>
		<script src="../../renderers/plain.jsonary.js"></script>
		<div align="center">
			<div id="content">
				<h1>Custom Renderers in Jsonary</h1>
				<div class="tagline">make things look pretty</div>

				<div id="nav">
					back to
					<a class="nav-link" href="../../">main page</a>
					<a class="nav-link" href="../">feature tour</a>
				</div>
				
				<div class="resource-list">
					The demos on this page use the following files:
					<ul>
						<li><span class="filename">jquery.js</span> - jQuery
						<li><span class="filename">jsonary.js</span> - the core Jsonary library
						<li><span class="filename">plain.jsonary.js</span> - a default set of renderers, that look similar to plain JSON
						<li><span class="filename">plain.jsonary.css</span> - the stylesheet used by the above renderers
					</ul>
				</div>
	
				<h2>Registering a custom renderer</h2>
				<div class="section">
					<p>The most basic way to register a renderer in Jsonary is this:
<pre class="example code">
Jsonary.render.register({
	"render": function (element, data, context) {
		// Fill the element with data
		// The element is emptied before this function is called,
		//   so you don't need to do that yourself
	},
	"filter": function (data, schemas, uiState) {
		// return boolean, declaring whether this renderer can render the item
		// Most of the time, it will look something like this:
		return schemas.containsUrl('some schema url');
	}
});
</pre>
					<p>The <code>containsUrl()</code> method matches the provided argument against the URLs of the schemas as a suffix (if it's a string), so you can just pass in <code>"mySchema.json"</code>, and it will match <code>http://example.com/schemas/mySchema.json</code>.  If you pass in a regular expression, then it tests the URLs using that regular expression.
					<p>There is also an optional <code>"update"</code> property, discussed later.
				</div>

				<h2>jQuery</h2>
				<div class="section">
					<p>There is a nice jQuery-friendly way to do this as well:
<pre class="example code">
$.renderJson.register({
	"render": function (query, data, context) {
		// Here, query is a jQuery object
	},
	"filter": function (data, schemas, uiState) {
		// same as above
	}
});
</pre>
				</div>

				<h2>Example</h2>
				<div class="section">
					<p>For this example, we're going to use jQuery.
					<p>Say we have a schema, like so: (<a href="example-schema.json">example-schema.json</a>)
<pre class="example code">
{
	"title": "Example schema",
	"type": "object",
	"properties": {
		"title": {"type": "string"},
		"message": {"type": "string"}
	},
	"required": ["title", "message"]
}
</pre>
					<p>If simply rendered a (read-only) instance described by this schema, it would look like this:
					<div class="example" id="example-no-renderer"></div>
					<script>
var rawData = {"title": "Instance title", "message": "This is the message content"};
var data = Jsonary.create(rawData, null, true);
data.addSchema("example-schema-copy.json").$renderTo("#example-no-renderer");
					</script>
					<p>Let's try adding a custom renderer that matches that schema:
<pre class="example code">
$.renderJson.register({
	"render": function (query, data, context) {
		var title = $('&lt;h3 class="exampleTitle" /&gt;');
		title.renderJson(data.property("title")).appendTo(query);
		var message = $('&lt;div class="exampleMessage" /&gt;');
		message.renderJson(data.property("message")).appendTo(query);
	},
	"filter": function (data, schemas, uiState) {
		return schemas.containsUrl("example-schema.json");
	}
});
</pre>
					<p>If we render the item, having defined this custom renderer (and a bit of CSS), it looks like this:
					<div class="example" id="example-renderer"></div>
					<script>
$.renderJson.register({
	"render": function (query, data, context) {
		var title = $('<h3 class="exampleTitle" />');
		title.renderJson(data.property("title")).appendTo(query);
		var message = $('<div class="exampleMessage" />');
		message.renderJson(data.property("message")).appendTo(query);
	},
	"filter": function (data, schemas, uiState) {
		return schemas.containsUrl("example-schema.json");
	}
});

var rawData = {"title": "Instance title", "message": "This is the message content"};
var data = Jsonary.create(rawData, null, true);
data.addSchema("example-schema.json").$renderTo("#example-renderer");
					</script>
				</div>
				
				<h2>Read/write example</h2>
				<div class="section">
					<p>You might wonder why in the previous example, we called <code>title.renderJson(data.property("title"))</code> instead of <code>title.text(data.propertyValue("title"))</code>.
					<p>To illustrate, let's try rendering an <em>editable</em> item using exactly the same renderer:
					<div class="example" id="example-renderer-editable"></div>
					<script>
var rawData = {"title": "Instance title", "message": "This is the message content"};
var data = Jsonary.create(rawData);
data.addSchema("example-schema.json").$renderTo('#example-renderer-editable');
					</script>
					<p>As you should hopefully be able to see, the item is now rendered with an editable title and message.
					<p>This is one of the advantages of the rendering using Jsonary.  If instead of figuring out how to render everything yourself, you pass back to Jsonary, it can select an appropriate renderer for you, and you can piggy-back on that renderer's behaviour.
				</div>
				
				<h2>Simultaneous read/write</h2>
				<div class="section">
					<p>Since the rendered versions of the items are tied to the data, if you update the data then the displayed version changes. Here we are rendering two copies of an instance:
					<div class="example" id="example-renderer-duplicate1"></div>
					<p>and:
					<div class="example" id="example-renderer-duplicate2"></div>
					<script>
var rawData = {"title": "Duplicated item", "message": "This is the message content"};
var data = Jsonary.create(rawData).addSchema("example-schema.json");
$('#example-renderer-duplicate1').renderJson(data);
$('#example-renderer-duplicate2').renderJson(data);
					</script>
					<p>If you edit the title or message in one of them, then the other should change to match, as the underlying data has changed.
				</div>

				<h2>Updates</h2>
				<div class="section">
					<p>How does this magical updating work?
					<p>At the top of this page, we briefly mentioned the optional <code>update</code> property of the renderer object.  We're not going to describe it in great detail, but the basic form is:
<pre class="example code">
Jsonary.render.register({
	"render": function (element, data, context) {
		// the element already contains the HTML returned by renderHtml()
	},
	"renderHtml": function (data, context) {
		// return HTML for the interface - if not present, default to empty string
	},
	"update": function (element, data, context, operation) {
		// update code
		// if you want a complete re-render, return boolean true
	}
	"filter": function (data, schemas, uiState) {
		return schemas.containsUrl('some schema url');
	}
});
</pre>
					<p>Whenever any data is changed, this function is called for that data <em>and its parent, grandparent and so on</em> anywhere that is still rendered on the page.  The mysterious third argument <code>operation</code> represents a single operation in a JSON Patch, which you can inspect to see what the actual change was.
					<p>Most of the time, you will not need to implement this function.  If you don't specify an update function, the default update function is called.  This function simply re-draws the item if the change occurred in the rendered data (or any of its immediate children, unless the update type is "replace").
					<p>You can fall back to the default update behaviour from within your update function by calling <code>this.defaultUpdate(element, data, operation)</code>.
				</div>
			</div>
		</div>
	</body>
</html>
