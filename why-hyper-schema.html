<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>Why JSON Hyper-Schema?</title>
		<link rel="stylesheet" href="css/main.css">
		<link rel="stylesheet" href="css/json-highlight.css">
		<link rel="stylesheet" href="renderers/basic.jsonary.css" />
		<link rel="stylesheet" href="renderers/common.css" />
		<meta name="viewport" content="width=960">
	</head>
	<body>
		<script src="jsonary.js"></script>
		<script src="plugins/jsonary.undo.js"></script>
		<script src="renderers/basic.jsonary.js"></script>
		<script src="renderers/list-schemas.js"></script>
		<script src="renderers/list-links.js"></script>
		<div align="center">
			<div id="content">
				<h1>Why JSON Hyper-Schema?</h1>
				<div class="tagline">What can it do for me?</div>

				<div id="nav">
					back to
					<a class="nav-link" href=".">main page</a>
				</div>
				
				<h2>Document your API</h2>
				<div class="section">
					<p>With growing use of RESTful design, APIs are becoming much friendlier for humans.  Often, an developer can look at JSON data and hazard a good guess about what the data represents - what parts represent links, what data they should submit along with requests.  If they guess wrong, they can always do a web search for the API docs, and find out more details.
					<p>Sadly, machines cannot do all of this.  However, JSON (Hyper-)Schema documents can describe your API in impressive detail.  They can be associated with data using HTTP headers (via a URL).  It is in many ways like your existing format/API docs - with one big difference:
					<p><em style="font-weight: bold; text-decoration: underline; font-style: normal">It's machine readable.</em>
				</div>
		
				<h2>Scenario 1: The fixed client</h2>
				<div class="section">
					<p>So you have a client for a web API.  It's nice and simple - it documents types of fruit.  If you discover a new type of fruit, you POST some data to <code>/fruits/</code>.  However, this knowledge about the API is coded into the client itself.
					<p>Then, the developer of the API add a new (optional) property that users can submit to <code>/fruits/</code>: "discoveryCountry".  There are a list of countries, and the value defaults to null if you don't specify it.
					<p>Things still work well enough - you don't use the new attribute, and it just defaults to null.  But one day, the developer makes "discoveryCountry" compulsory... and your client no longer works.
					<p>You panic and fix it, and all is good.  But then, by popular demand, "Antarctica" is renamed after Sir Ranulph Feinnes.  A very small proportion of your requests start failing, and it takes you a while to notice.
				</div>
				
				<h2>Scenario 2: Using hyper-schema</h2>
				<div class="section">
					<p>So you have a client for a web API, that uses hyper-schema.  When it fetches <code>/fruits/</code> to get the list of fruits, the URL for a hyper-schema is included in the header.
					<p>By fetching this hyper-schema and inspecting it, the client knows it can POST data to <code>/fruits/</code>, and what data it should provide.
					<p>The developer of the API adds the "discoveryCountry" property.  Next time the client fetches the hyper-schema, it will see that the data it can POST now includes an optional "discoveryCountry" property, and it also knows the list of acceptable country values.
					<p>The client therefore displays a drop-down menu in the "fruit submission" form, allowing the user to optionally specify a country.  This drop-down menu is labelled "Discovered in", and there is a helpful mouse-over text explaining what it's for - all extracted from the hyper-schema.  You can customise this display in your client, but it first appears in direct reaction to an API change, keeping your client functional when the developer makes the property compulsory.
					<p>When "Antarctica" is renamed, the API developer also changes the list of acceptable country values defined in the hyper-schema.  The client alters its drop-down menu to include the new name, and everyone is happy.
				</div>
				
				<h2>"OK - so what's the format?"</h2>
				<div class="section">
					<p>Here's a <a href="hyper-schema-intro.html">quick walkthrough</a>, documenting some example data with a hyper-schema.
					<p>The full JSON (Hyper-)Schema specification is at <a href="http://json-schema.org/">http://json-schema.org/</a>.
				</div>

				<h2>"How do I add this to my API?"</h2>
				<div class="section">
					<p>First - write JSON Hyper-Schemas for the different types of data you return, documenting the actions that can be taken (including the structure of any submitted data).
					<p>Then simply provide URLS for the appropriate schemas in the HTTP headers.  This can be done either with the HTTP <a href="http://tools.ietf.org/html/draft-nottingham-http-link-header-10">Link header</a> (with <code>rel="describedby"</code>), or using a parameter <code>profile=...</code> in the Content-Type:
<pre class="example code">
Content-Type: application/json; profile=/schemas/whatever
</pre>
<pre class="example code">
Link: &lt;/schemas/whatever&gt;; rel="describedby"
</pre>
				</div>

				<h2>"Sounds good - but clients still have to parse the hyper-schema."</h2>
				<div class="section">
					<p>Yes, that's true.  Using JSON Hyper-Schema allows clients to be incredibly flexible - but to take advantage of that, they have to understand and deal with hyper-schemas.
					<p>Unless...
				</div>

				<h2>"Unless what?"</h2>
				<div class="section">
					<p>Unless there's a nice library to do that for you, such as Jsonary.  Something that lets you fetch data with schemas already attached, and quickly assemble flexible clients.
					<p>For more information, see <a href="why-jsonary.html">Why would I use Jsonary?</a>.
				</div>

				<h2>"But I'm just writing the API - I don't care about clients."</h2>
				<div class="section">
					<p>First - from a user's perspective, an API is only as good as the clients that use it.  An API documented with hyper-schemas allows for more flexible clients, and will allow developers to get up and running with your API faster.
					<p>But more selfishly - what if, just by providing your API documentation as JSON Hyper-Schema, you could have a fully-featured debugging client for minimal effort?  No more messing around with <code>curl</code>, no more typos in your hand-written JSON - just clicking links and taking names.  That possibility was one of the original motivations behind Jsonary, and it's still one of the core goals.
					<p>JSON Hyper-Schema is an extremely powerful and flexible way to enhance JSON APIs, and the more people on board, the better.				
				</div>
			</div>
		</div>
		<script src="js/json-highlight.js"></script>
	</body>
</html>
